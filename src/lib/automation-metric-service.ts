/**
 * Automation Metric Service â€” Track and compute automation usage rates
 *
 * Measures how effectively automation features are being utilized:
 * auto-suggested systems, template responses, IDV automation, API-ready systems.
 *
 * Multi-tenant safe: all queries scoped by tenantId.
 */

import { prisma } from "./prisma";

export interface AutomationSnapshot {
  month: string;
  autoSuggestedPct: number;
  templateResponsePct: number;
  idvAutomationPct: number;
  apiReadyPct: number;
  vendorAutoGeneratedPct: number;
  overallAutomationScore: number;
}

function safePct(num: number, denom: number): number {
  if (denom === 0) return 0;
  return Math.round((num / denom) * 10000) / 100;
}

/**
 * Compute current automation metrics for a tenant.
 */
export async function computeAutomationMetrics(
  tenantId: string,
): Promise<AutomationSnapshot> {
  const now = new Date();
  const month = new Date(now.getFullYear(), now.getMonth(), 1);

  const [
    caseSystemLinks,
    autoSuggestedLinks,
    responseDocsTotal,
    responseDocsFromTemplate,
    idvTotal,
    idvAutomated,
    systemsTotal,
    systemsApiReady,
    vendorRequestsTotal,
    vendorRequestsAuto,
    totalDsars,
  ] = await Promise.all([
    prisma.caseSystemLink.count({ where: { tenantId } }),
    prisma.caseSystemLink.count({ where: { tenantId, suggestedByDiscovery: true } }),
    prisma.responseDocument.count({ where: { tenantId } }),
    prisma.responseDocument.count({ where: { tenantId, templateId: { not: null } } }),
    prisma.idvRequest.count({ where: { tenantId } }),
    prisma.idvRequest.count({ where: { tenantId, status: "APPROVED" } }),
    prisma.system.count({ where: { tenantId } }),
    prisma.system.count({ where: { tenantId, automationReadiness: "API_AVAILABLE" } }),
    prisma.vendorRequest.count({ where: { tenantId } }),
    prisma.vendorRequest.count({ where: { tenantId, status: "CLOSED" } }),
    prisma.dSARCase.count({ where: { tenantId } }),
  ]);

  const autoSuggestedPct = safePct(autoSuggestedLinks, caseSystemLinks);
  const templateResponsePct = safePct(responseDocsFromTemplate, responseDocsTotal);
  const idvAutomationPct = safePct(idvAutomated, idvTotal);
  const apiReadyPct = safePct(systemsApiReady, systemsTotal);
  const vendorAutoGeneratedPct = safePct(vendorRequestsAuto, vendorRequestsTotal);

  const overallAutomationScore = Math.round(
    (autoSuggestedPct * 0.25 +
      templateResponsePct * 0.25 +
      idvAutomationPct * 0.2 +
      apiReadyPct * 0.15 +
      vendorAutoGeneratedPct * 0.15) *
      10,
  ) / 10;

  const snapshot: AutomationSnapshot = {
    month: month.toISOString(),
    autoSuggestedPct,
    templateResponsePct,
    idvAutomationPct,
    apiReadyPct,
    vendorAutoGeneratedPct,
    overallAutomationScore,
  };

  // Store monthly snapshot using actual schema fields (integer counts)
  await prisma.automationMetric.upsert({
    where: { tenantId_month: { tenantId, month } },
    update: {
      totalCases: totalDsars,
      casesWithAutoSystems: autoSuggestedLinks,
      vendorRequestsTotal,
      vendorRequestsAuto,
      responsesTotal: responseDocsTotal,
      responsesViaTemplate: responseDocsFromTemplate,
      idvRequestsTotal: idvTotal,
      idvRequestsAutomated: idvAutomated,
      avgProcessingMinutes: null,
    },
    create: {
      tenantId,
      month,
      totalCases: totalDsars,
      casesWithAutoSystems: autoSuggestedLinks,
      vendorRequestsTotal,
      vendorRequestsAuto,
      responsesTotal: responseDocsTotal,
      responsesViaTemplate: responseDocsFromTemplate,
      idvRequestsTotal: idvTotal,
      idvRequestsAutomated: idvAutomated,
    },
  });

  return snapshot;
}

/**
 * Get automation metric history for trend analysis.
 */
export async function getAutomationHistory(
  tenantId: string,
  months: number = 12,
): Promise<AutomationSnapshot[]> {
  const since = new Date();
  since.setMonth(since.getMonth() - months);

  const records = await prisma.automationMetric.findMany({
    where: {
      tenantId,
      month: { gte: since },
    },
    orderBy: { month: "asc" },
  });

  return records.map((r) => ({
    month: r.month.toISOString(),
    autoSuggestedPct: safePct(r.casesWithAutoSystems, r.totalCases),
    templateResponsePct: safePct(r.responsesViaTemplate, r.responsesTotal),
    idvAutomationPct: safePct(r.idvRequestsAutomated, r.idvRequestsTotal),
    apiReadyPct: 0, // not tracked in counts table
    vendorAutoGeneratedPct: safePct(r.vendorRequestsAuto, r.vendorRequestsTotal),
    overallAutomationScore: Math.round(
      (safePct(r.casesWithAutoSystems, r.totalCases) * 0.3 +
        safePct(r.responsesViaTemplate, r.responsesTotal) * 0.3 +
        safePct(r.idvRequestsAutomated, r.idvRequestsTotal) * 0.2 +
        safePct(r.vendorRequestsAuto, r.vendorRequestsTotal) * 0.2) *
        10,
    ) / 10,
  }));
}

/**
 * Calculate automation ROI metrics.
 */
export async function computeAutomationROI(
  tenantId: string,
): Promise<{
  estimatedHoursSavedMonthly: number;
  estimatedCostSavedMonthly: number;
  automationAdoptionRate: number;
  topOpportunity: string;
}> {
  const config = await prisma.privacyKpiConfig.findUnique({
    where: { tenantId },
  });

  const minutesManual = config?.estimatedMinutesManual ?? 480;
  const minutesAutomated = config?.estimatedMinutesAutomated ?? 120;
  const costPerDsar = config?.estimatedCostPerDsar ?? 150;
  const timeSavedPerDsar = minutesManual - minutesAutomated;

  const now = new Date();
  const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
  const closedThisMonth = await prisma.dSARCase.count({
    where: {
      tenantId,
      status: { in: ["CLOSED", "REJECTED"] },
      updatedAt: { gte: monthStart },
    },
  });

  const metrics = await computeAutomationMetrics(tenantId);
  const adoptionRate = metrics.overallAutomationScore;

  const hoursSaved = Math.round((closedThisMonth * timeSavedPerDsar * (adoptionRate / 100)) / 60 * 10) / 10;
  const costSaved = Math.round(closedThisMonth * costPerDsar * (adoptionRate / 100) * 0.3);

  // Determine top automation opportunity
  const opportunities = [
    { name: "System auto-discovery", pct: metrics.autoSuggestedPct },
    { name: "Template responses", pct: metrics.templateResponsePct },
    { name: "IDV automation", pct: metrics.idvAutomationPct },
    { name: "API-ready systems", pct: metrics.apiReadyPct },
    { name: "Vendor auto-generation", pct: metrics.vendorAutoGeneratedPct },
  ];
  opportunities.sort((a, b) => a.pct - b.pct);
  const topOpportunity = opportunities[0]?.name ?? "N/A";

  return {
    estimatedHoursSavedMonthly: hoursSaved,
    estimatedCostSavedMonthly: costSaved,
    automationAdoptionRate: adoptionRate,
    topOpportunity,
  };
}
