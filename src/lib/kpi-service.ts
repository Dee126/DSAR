/**
 * KPI Service — Executive Privacy KPI calculations
 *
 * Aggregates operational DSAR, Incident, Vendor and SLA data
 * into strategic KPIs. Stores snapshots for trend analysis.
 *
 * Multi-tenant safe: all queries scoped by tenantId.
 */

import { prisma } from "./prisma";
import type { KpiSnapshotPeriod } from "@prisma/client";

export interface KpiResult {
  // DSAR metrics
  totalDsars: number;
  openDsars: number;
  closedDsars: number;
  avgTimeToCloseDays: number | null;
  medianTimeToCloseDays: number | null;
  extensionRatePct: number | null;
  overdueRatePct: number | null;
  dsarsByType: Record<string, number>;
  dsarsLinkedToIncidentPct: number | null;
  // Risk metrics
  riskDistribution: { green: number; yellow: number; red: number };
  highRiskCasesCount: number;
  incidentLinkedHighRiskCount: number;
  vendorOverdueCount: number;
  // Automation metrics
  autoSuggestedSystemsPct: number | null;
  vendorAutoGeneratedPct: number | null;
  templateResponsePct: number | null;
  idvAutomationPct: number | null;
  apiReadySystemsPct: number | null;
  // Governance metrics
  dpaOnFilePct: number | null;
  systemsCompleteMetaPct: number | null;
  retentionDefinedPct: number | null;
  thirdCountryTransferRatio: number | null;
  // Financial proxy
  estimatedCostPerDsar: number | null;
  estimatedTimeSavedPerDsar: number | null;
  totalTimeSavedMonthly: number | null;
  // Maturity
  maturityScore: number | null;
}

function pct(numerator: number, denominator: number): number | null {
  if (denominator === 0) return null;
  return Math.round((numerator / denominator) * 10000) / 100;
}

function median(values: number[]): number | null {
  if (values.length === 0) return null;
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted.length % 2 !== 0
    ? sorted[mid]
    : (sorted[mid - 1] + sorted[mid]) / 2;
}

/**
 * Calculate all KPIs for a tenant within a date range.
 */
export async function calculateKPIs(
  tenantId: string,
  startDate?: Date,
  endDate?: Date,
): Promise<KpiResult> {
  const dateFilter = startDate && endDate
    ? { createdAt: { gte: startDate, lte: endDate } }
    : {};

  // ── DSAR Metrics ────────────────────────────────────────────────
  const allCases = await prisma.dSARCase.findMany({
    where: { tenantId, ...dateFilter },
    select: {
      id: true, status: true, type: true, createdAt: true,
      dsarIncidents: { select: { id: true } },
    },
  });

  const closedCases = await prisma.dSARCase.findMany({
    where: {
      tenantId, status: { in: ["CLOSED", "REJECTED"] },
      ...(startDate && endDate ? { createdAt: { gte: startDate, lte: endDate } } : {}),
    },
    select: { createdAt: true, updatedAt: true },
  });

  const closeTimes = closedCases.map((c) =>
    (c.updatedAt.getTime() - c.createdAt.getTime()) / (1000 * 60 * 60 * 24),
  );

  const avgClose = closeTimes.length > 0
    ? Math.round((closeTimes.reduce((a, b) => a + b, 0) / closeTimes.length) * 10) / 10
    : null;

  const totalDsars = allCases.length;
  const openDsars = allCases.filter((c) => !["CLOSED", "REJECTED"].includes(c.status)).length;
  const closedDsars = totalDsars - openDsars;

  const dsarsByType: Record<string, number> = {};
  for (const c of allCases) {
    dsarsByType[c.type] = (dsarsByType[c.type] || 0) + 1;
  }

  const dsarsWithIncident = allCases.filter((c) => c.dsarIncidents.length > 0).length;

  // Extension rate
  const extensions = await prisma.deadlineEvent.count({
    where: { tenantId, eventType: "EXTENDED", ...dateFilter },
  });

  // Overdue rate
  const overdueDeadlines = await prisma.caseDeadline.count({
    where: {
      tenantId,
      effectiveDueAt: { lt: new Date() },
      case: { status: { notIn: ["CLOSED", "REJECTED"] } },
    },
  });

  // ── Risk Metrics ────────────────────────────────────────────────
  const deadlines = await prisma.caseDeadline.findMany({
    where: { tenantId, case: { status: { notIn: ["CLOSED", "REJECTED"] } } },
    select: { currentRisk: true, caseId: true },
  });

  const riskDistribution = { green: 0, yellow: 0, red: 0 };
  for (const d of deadlines) {
    if (d.currentRisk === "RED") riskDistribution.red++;
    else if (d.currentRisk === "YELLOW") riskDistribution.yellow++;
    else riskDistribution.green++;
  }

  const highRiskCases = deadlines.filter(
    (d) => d.currentRisk === "RED",
  );

  const incidentLinkedHighRisk = await prisma.dsarIncident.count({
    where: {
      tenantId,
      caseId: { in: highRiskCases.map((d) => d.caseId) },
    },
  });

  const vendorOverdueCount = await prisma.vendorRequest.count({
    where: {
      tenantId,
      status: { in: ["OVERDUE", "ESCALATED"] },
    },
  });

  // ── Automation Metrics ──────────────────────────────────────────
  const caseSystemLinks = await prisma.caseSystemLink.count({ where: { tenantId } });
  const autoSuggestedLinks = await prisma.caseSystemLink.count({
    where: { tenantId, suggestedByDiscovery: true },
  });

  const vendorRequestsTotal = await prisma.vendorRequest.count({ where: { tenantId } });

  const responseDocsTotal = await prisma.responseDocument.count({ where: { tenantId } });
  const responseDocsFromTemplate = await prisma.responseDocument.count({
    where: { tenantId, templateId: { not: null } },
  });

  const idvRequestsTotal = await prisma.idvRequest.count({ where: { tenantId } });

  const systemsTotal = await prisma.system.count({ where: { tenantId } });
  const systemsApiReady = await prisma.system.count({
    where: { tenantId, automationReadiness: "API_AVAILABLE" },
  });

  // ── Governance Metrics ──────────────────────────────────────────
  const vendorsTotal = await prisma.vendor.count({ where: { tenantId } });
  const vendorsWithDpa = await prisma.vendor.count({
    where: { tenantId, dpaOnFile: true },
  });

  const systemsWithCategories = await prisma.system.count({
    where: {
      tenantId,
      description: { not: null },
      dataCategories: { some: {} },
    },
  });

  const systemsWithRetention = await prisma.systemDataCategory.count({
    where: {
      tenantId,
      retentionPeriod: { not: null },
    },
  });
  const totalCategories = await prisma.systemDataCategory.count({ where: { tenantId } });

  const thirdCountrySystems = await prisma.system.count({
    where: { tenantId, thirdCountryTransfers: true },
  });

  // ── Financial Proxy ─────────────────────────────────────────────
  const config = await prisma.privacyKpiConfig.findUnique({
    where: { tenantId },
  });

  const costPerDsar = config?.estimatedCostPerDsar ?? 150;
  const minutesManual = config?.estimatedMinutesManual ?? 480;
  const minutesAutomated = config?.estimatedMinutesAutomated ?? 120;
  const timeSavedPerDsar = minutesManual - minutesAutomated;
  const monthlyClosed = closedDsars; // within date range
  const totalTimeSavedMonthly = monthlyClosed * timeSavedPerDsar;

  // ── Maturity Score ──────────────────────────────────────────────
  const weights = (config?.maturityWeights as Record<string, number>) ?? {
    documentation: 0.2,
    automation: 0.25,
    sla_compliance: 0.25,
    incident_integration: 0.15,
    vendor_coordination: 0.15,
  };

  const documentationScore = pct(systemsWithCategories, systemsTotal) ?? 0;
  const automationScore = pct(autoSuggestedLinks + (responseDocsFromTemplate || 0), caseSystemLinks + responseDocsTotal || 1) ?? 0;
  const slaComplianceScore = openDsars > 0 ? Math.max(0, 100 - (pct(overdueDeadlines, openDsars) ?? 0)) : 100;
  const incidentIntScore = totalDsars > 0 ? Math.min(100, (pct(dsarsWithIncident, totalDsars) ?? 0) + 50) : 50;
  const vendorCoordScore = vendorRequestsTotal > 0
    ? Math.max(0, 100 - (pct(vendorOverdueCount, vendorRequestsTotal) ?? 0) * 2)
    : 50;

  const maturityScore = Math.round(
    (documentationScore * weights.documentation +
    automationScore * weights.automation +
    slaComplianceScore * weights.sla_compliance +
    incidentIntScore * weights.incident_integration +
    vendorCoordScore * weights.vendor_coordination) * 10,
  ) / 10;

  return {
    totalDsars,
    openDsars,
    closedDsars,
    avgTimeToCloseDays: avgClose,
    medianTimeToCloseDays: median(closeTimes),
    extensionRatePct: pct(extensions, totalDsars),
    overdueRatePct: pct(overdueDeadlines, openDsars > 0 ? openDsars : totalDsars),
    dsarsByType,
    dsarsLinkedToIncidentPct: pct(dsarsWithIncident, totalDsars),
    riskDistribution,
    highRiskCasesCount: highRiskCases.length,
    incidentLinkedHighRiskCount: incidentLinkedHighRisk,
    vendorOverdueCount,
    autoSuggestedSystemsPct: pct(autoSuggestedLinks, caseSystemLinks),
    vendorAutoGeneratedPct: null, // computed from automation_metrics
    templateResponsePct: pct(responseDocsFromTemplate, responseDocsTotal),
    idvAutomationPct: pct(idvRequestsTotal, totalDsars),
    apiReadySystemsPct: pct(systemsApiReady, systemsTotal),
    dpaOnFilePct: pct(vendorsWithDpa, vendorsTotal),
    systemsCompleteMetaPct: pct(systemsWithCategories, systemsTotal),
    retentionDefinedPct: pct(systemsWithRetention, totalCategories),
    thirdCountryTransferRatio: pct(thirdCountrySystems, systemsTotal),
    estimatedCostPerDsar: costPerDsar,
    estimatedTimeSavedPerDsar: timeSavedPerDsar,
    totalTimeSavedMonthly: totalTimeSavedMonthly,
    maturityScore,
  };
}

/**
 * Store a KPI snapshot for the given date.
 */
export async function storeKpiSnapshot(
  tenantId: string,
  period: KpiSnapshotPeriod = "MONTHLY",
  snapshotDate?: Date,
) {
  const date = snapshotDate || new Date();
  const normalizedDate = new Date(date.getFullYear(), date.getMonth(), 1);

  const kpi = await calculateKPIs(tenantId);

  return prisma.privacyKpiSnapshot.upsert({
    where: {
      tenantId_period_snapshotDate: {
        tenantId,
        period,
        snapshotDate: normalizedDate,
      },
    },
    update: { ...snapshotToData(kpi), rawData: JSON.parse(JSON.stringify(kpi)) },
    create: {
      tenantId,
      period,
      snapshotDate: normalizedDate,
      ...snapshotToData(kpi),
      rawData: JSON.parse(JSON.stringify(kpi)),
    },
  });
}

function snapshotToData(kpi: KpiResult) {
  return {
    totalDsars: kpi.totalDsars,
    openDsars: kpi.openDsars,
    closedDsars: kpi.closedDsars,
    avgTimeToCloseDays: kpi.avgTimeToCloseDays,
    medianTimeToCloseDays: kpi.medianTimeToCloseDays,
    extensionRatePct: kpi.extensionRatePct,
    overdueRatePct: kpi.overdueRatePct,
    dsarsByType: kpi.dsarsByType,
    dsarsLinkedToIncidentPct: kpi.dsarsLinkedToIncidentPct,
    riskDistribution: kpi.riskDistribution,
    highRiskCasesCount: kpi.highRiskCasesCount,
    incidentLinkedHighRiskCount: kpi.incidentLinkedHighRiskCount,
    vendorOverdueCount: kpi.vendorOverdueCount,
    autoSuggestedSystemsPct: kpi.autoSuggestedSystemsPct,
    vendorAutoGeneratedPct: kpi.vendorAutoGeneratedPct,
    templateResponsePct: kpi.templateResponsePct,
    idvAutomationPct: kpi.idvAutomationPct,
    apiReadySystemsPct: kpi.apiReadySystemsPct,
    dpaOnFilePct: kpi.dpaOnFilePct,
    systemsCompleteMetaPct: kpi.systemsCompleteMetaPct,
    retentionDefinedPct: kpi.retentionDefinedPct,
    thirdCountryTransferRatio: kpi.thirdCountryTransferRatio,
    estimatedCostPerDsar: kpi.estimatedCostPerDsar,
    estimatedTimeSavedPerDsar: kpi.estimatedTimeSavedPerDsar,
    totalTimeSavedMonthly: kpi.totalTimeSavedMonthly,
    maturityScore: kpi.maturityScore,
  };
}

/**
 * Get historical KPI snapshots for trend analysis.
 */
export async function getKpiSnapshots(
  tenantId: string,
  months: number = 12,
  period: KpiSnapshotPeriod = "MONTHLY",
) {
  const since = new Date();
  since.setMonth(since.getMonth() - months);

  return prisma.privacyKpiSnapshot.findMany({
    where: {
      tenantId,
      period,
      snapshotDate: { gte: since },
    },
    orderBy: { snapshotDate: "asc" },
  });
}

/**
 * Calculate maturity scores by domain and store them.
 */
export async function calculateMaturityScores(tenantId: string) {
  const kpi = await calculateKPIs(tenantId);
  const now = new Date();
  const month = new Date(now.getFullYear(), now.getMonth(), 1);

  const scores = [
    {
      domain: "DOCUMENTATION" as const,
      score: kpi.systemsCompleteMetaPct ?? 0,
      details: { dpaOnFile: kpi.dpaOnFilePct, retention: kpi.retentionDefinedPct },
    },
    {
      domain: "AUTOMATION" as const,
      score: Math.min(100, (kpi.autoSuggestedSystemsPct ?? 0) * 0.4 + (kpi.templateResponsePct ?? 0) * 0.3 + (kpi.apiReadySystemsPct ?? 0) * 0.3),
      details: { autoSystems: kpi.autoSuggestedSystemsPct, templates: kpi.templateResponsePct, apiReady: kpi.apiReadySystemsPct },
    },
    {
      domain: "SLA_COMPLIANCE" as const,
      score: Math.max(0, 100 - (kpi.overdueRatePct ?? 0)),
      details: { overdueRate: kpi.overdueRatePct, extensionRate: kpi.extensionRatePct },
    },
    {
      domain: "INCIDENT_INTEGRATION" as const,
      score: Math.min(100, (kpi.dsarsLinkedToIncidentPct ?? 0) + 50),
      details: { linkedPct: kpi.dsarsLinkedToIncidentPct, highRisk: kpi.incidentLinkedHighRiskCount },
    },
    {
      domain: "VENDOR_COORDINATION" as const,
      score: kpi.vendorOverdueCount === 0 ? 100 : Math.max(0, 100 - kpi.vendorOverdueCount * 10),
      details: { overdueRequests: kpi.vendorOverdueCount, dpaOnFile: kpi.dpaOnFilePct },
    },
  ];

  for (const s of scores) {
    await prisma.maturityScore.upsert({
      where: {
        tenantId_domain_month: { tenantId, domain: s.domain, month },
      },
      update: { score: s.score, details: s.details },
      create: { tenantId, domain: s.domain, month, score: s.score, details: s.details },
    });
  }

  return scores;
}
