/**
 * KPI Service — Executive Privacy KPI calculations
 *
 * Aggregates operational DSAR, Incident, Vendor and SLA data
 * into strategic KPIs. Stores snapshots for trend analysis.
 *
 * Multi-tenant safe: all queries scoped by tenantId.
 *
 * Sprint 9.3: Optimized with batched queries (Promise.all),
 * groupBy aggregation instead of loading full rows,
 * and cache integration.
 */

import { prisma } from "./prisma";
import { cache, cacheKey, CacheTTL } from "./cache-service";
import type { KpiSnapshotPeriod } from "@prisma/client";

export interface KpiResult {
  // DSAR metrics
  totalDsars: number;
  openDsars: number;
  closedDsars: number;
  avgTimeToCloseDays: number | null;
  medianTimeToCloseDays: number | null;
  extensionRatePct: number | null;
  overdueRatePct: number | null;
  dsarsByType: Record<string, number>;
  dsarsLinkedToIncidentPct: number | null;
  // Risk metrics
  riskDistribution: { green: number; yellow: number; red: number };
  highRiskCasesCount: number;
  incidentLinkedHighRiskCount: number;
  vendorOverdueCount: number;
  // Automation metrics
  autoSuggestedSystemsPct: number | null;
  vendorAutoGeneratedPct: number | null;
  templateResponsePct: number | null;
  idvAutomationPct: number | null;
  apiReadySystemsPct: number | null;
  // Governance metrics
  dpaOnFilePct: number | null;
  systemsCompleteMetaPct: number | null;
  retentionDefinedPct: number | null;
  thirdCountryTransferRatio: number | null;
  // Financial proxy
  estimatedCostPerDsar: number | null;
  estimatedTimeSavedPerDsar: number | null;
  totalTimeSavedMonthly: number | null;
  // Maturity
  maturityScore: number | null;
}

function pct(numerator: number, denominator: number): number | null {
  if (denominator === 0) return null;
  return Math.round((numerator / denominator) * 10000) / 100;
}

function median(values: number[]): number | null {
  if (values.length === 0) return null;
  const sorted = [...values].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted.length % 2 !== 0
    ? sorted[mid]
    : (sorted[mid - 1] + sorted[mid]) / 2;
}

/**
 * Calculate all KPIs for a tenant within a date range.
 *
 * Optimized: uses batched parallel queries instead of sequential N+1.
 * Uses groupBy for type/status aggregation instead of loading full rows.
 */
export async function calculateKPIs(
  tenantId: string,
  startDate?: Date,
  endDate?: Date,
): Promise<KpiResult> {
  // Check cache first
  const ck = cacheKey(tenantId, "kpi", {
    start: startDate?.toISOString(),
    end: endDate?.toISOString(),
  });
  const cached = await cache.get<KpiResult>(ck);
  if (cached) return cached;

  const dateFilter = startDate && endDate
    ? { createdAt: { gte: startDate, lte: endDate } }
    : {};

  // ── Batch 1: Core counts (all parallel) ────────────────────────
  const [
    // DSAR type distribution via groupBy (avoids loading all rows)
    casesByType,
    // Total + open counts
    totalDsars,
    openDsars,
    // Closed cases for avg time calculation
    closedCases,
    // Incident-linked DSARs count
    dsarsWithIncidentCount,
    // Extension count
    extensions,
    // Overdue deadlines
    overdueDeadlines,
    // Risk distribution via groupBy
    riskGroups,
    // Vendor overdue
    vendorOverdueCount,
  ] = await Promise.all([
    prisma.dSARCase.groupBy({
      by: ["type"],
      where: { tenantId, ...dateFilter },
      _count: { _all: true },
    }),
    prisma.dSARCase.count({ where: { tenantId, ...dateFilter } }),
    prisma.dSARCase.count({
      where: {
        tenantId,
        status: { notIn: ["CLOSED", "REJECTED"] },
        ...dateFilter,
      },
    }),
    prisma.dSARCase.findMany({
      where: {
        tenantId, status: { in: ["CLOSED", "REJECTED"] },
        ...(startDate && endDate ? { createdAt: { gte: startDate, lte: endDate } } : {}),
      },
      select: { createdAt: true, updatedAt: true },
    }),
    prisma.dsarIncident.count({
      where: {
        tenantId,
        case: { tenantId, ...dateFilter },
      },
    }),
    prisma.deadlineEvent.count({
      where: { tenantId, eventType: "EXTENDED", ...dateFilter },
    }),
    prisma.caseDeadline.count({
      where: {
        tenantId,
        effectiveDueAt: { lt: new Date() },
        case: { status: { notIn: ["CLOSED", "REJECTED"] } },
      },
    }),
    prisma.caseDeadline.groupBy({
      by: ["currentRisk"],
      where: { tenantId, case: { status: { notIn: ["CLOSED", "REJECTED"] } } },
      _count: { _all: true },
    }),
    prisma.vendorRequest.count({
      where: { tenantId, status: { in: ["OVERDUE", "ESCALATED"] } },
    }),
  ]);

  const closedDsars = totalDsars - openDsars;
  const closeTimes = closedCases.map((c) =>
    (c.updatedAt.getTime() - c.createdAt.getTime()) / (1000 * 60 * 60 * 24),
  );
  const avgClose = closeTimes.length > 0
    ? Math.round((closeTimes.reduce((a, b) => a + b, 0) / closeTimes.length) * 10) / 10
    : null;

  const dsarsByType: Record<string, number> = {};
  for (const g of casesByType) {
    dsarsByType[g.type] = g._count._all;
  }

  // Build risk distribution from groupBy
  const riskDistribution = { green: 0, yellow: 0, red: 0 };
  for (const g of riskGroups) {
    if (g.currentRisk === "RED") riskDistribution.red = g._count._all;
    else if (g.currentRisk === "YELLOW") riskDistribution.yellow = g._count._all;
    else riskDistribution.green = g._count._all;
  }

  // Get high risk case IDs for incident linkage
  const highRiskCaseIds = riskDistribution.red > 0
    ? await prisma.caseDeadline.findMany({
        where: { tenantId, currentRisk: "RED", case: { status: { notIn: ["CLOSED", "REJECTED"] } } },
        select: { caseId: true },
      })
    : [];

  // ── Batch 2: Automation + Governance counts (all parallel) ────
  const [
    incidentLinkedHighRisk,
    caseSystemLinks,
    autoSuggestedLinks,
    vendorRequestsTotal,
    responseDocsTotal,
    responseDocsFromTemplate,
    idvRequestsTotal,
    systemsTotal,
    systemsApiReady,
    vendorsTotal,
    vendorsWithDpa,
    systemsWithCategories,
    systemsWithRetention,
    totalCategories,
    thirdCountrySystems,
    config,
  ] = await Promise.all([
    highRiskCaseIds.length > 0
      ? prisma.dsarIncident.count({
          where: { tenantId, caseId: { in: highRiskCaseIds.map((d) => d.caseId) } },
        })
      : Promise.resolve(0),
    prisma.caseSystemLink.count({ where: { tenantId } }),
    prisma.caseSystemLink.count({ where: { tenantId, suggestedByDiscovery: true } }),
    prisma.vendorRequest.count({ where: { tenantId } }),
    prisma.responseDocument.count({ where: { tenantId } }),
    prisma.responseDocument.count({ where: { tenantId, templateId: { not: null } } }),
    prisma.idvRequest.count({ where: { tenantId } }),
    prisma.system.count({ where: { tenantId } }),
    prisma.system.count({ where: { tenantId, automationReadiness: "API_AVAILABLE" } }),
    prisma.vendor.count({ where: { tenantId } }),
    prisma.vendor.count({ where: { tenantId, dpaOnFile: true } }),
    prisma.system.count({
      where: { tenantId, description: { not: null }, dataCategories: { some: {} } },
    }),
    prisma.systemDataCategory.count({ where: { tenantId, retentionPeriod: { not: null } } }),
    prisma.systemDataCategory.count({ where: { tenantId } }),
    prisma.system.count({ where: { tenantId, thirdCountryTransfers: true } }),
    prisma.privacyKpiConfig.findUnique({ where: { tenantId } }),
  ]);

  // ── Financial Proxy ─────────────────────────────────────────────
  const costPerDsar = config?.estimatedCostPerDsar ?? 150;
  const minutesManual = config?.estimatedMinutesManual ?? 480;
  const minutesAutomated = config?.estimatedMinutesAutomated ?? 120;
  const timeSavedPerDsar = minutesManual - minutesAutomated;
  const monthlyClosed = closedDsars;
  const totalTimeSavedMonthly = monthlyClosed * timeSavedPerDsar;

  // ── Maturity Score ──────────────────────────────────────────────
  const weights = (config?.maturityWeights as Record<string, number>) ?? {
    documentation: 0.2,
    automation: 0.25,
    sla_compliance: 0.25,
    incident_integration: 0.15,
    vendor_coordination: 0.15,
  };

  // Count unique DSARs linked to incidents
  const dsarsLinkedPct = totalDsars > 0
    ? pct(dsarsWithIncidentCount, totalDsars)
    : null;

  const documentationScore = pct(systemsWithCategories, systemsTotal) ?? 0;
  const automationScore = pct(autoSuggestedLinks + (responseDocsFromTemplate || 0), caseSystemLinks + responseDocsTotal || 1) ?? 0;
  const slaComplianceScore = openDsars > 0 ? Math.max(0, 100 - (pct(overdueDeadlines, openDsars) ?? 0)) : 100;
  const incidentIntScore = totalDsars > 0 ? Math.min(100, (dsarsLinkedPct ?? 0) + 50) : 50;
  const vendorCoordScore = vendorRequestsTotal > 0
    ? Math.max(0, 100 - (pct(vendorOverdueCount, vendorRequestsTotal) ?? 0) * 2)
    : 50;

  const maturityScore = Math.round(
    (documentationScore * weights.documentation +
    automationScore * weights.automation +
    slaComplianceScore * weights.sla_compliance +
    incidentIntScore * weights.incident_integration +
    vendorCoordScore * weights.vendor_coordination) * 10,
  ) / 10;

  const result: KpiResult = {
    totalDsars,
    openDsars,
    closedDsars,
    avgTimeToCloseDays: avgClose,
    medianTimeToCloseDays: median(closeTimes),
    extensionRatePct: pct(extensions, totalDsars),
    overdueRatePct: pct(overdueDeadlines, openDsars > 0 ? openDsars : totalDsars),
    dsarsByType,
    dsarsLinkedToIncidentPct: dsarsLinkedPct,
    riskDistribution,
    highRiskCasesCount: riskDistribution.red,
    incidentLinkedHighRiskCount: incidentLinkedHighRisk,
    vendorOverdueCount,
    autoSuggestedSystemsPct: pct(autoSuggestedLinks, caseSystemLinks),
    vendorAutoGeneratedPct: null,
    templateResponsePct: pct(responseDocsFromTemplate, responseDocsTotal),
    idvAutomationPct: pct(idvRequestsTotal, totalDsars),
    apiReadySystemsPct: pct(systemsApiReady, systemsTotal),
    dpaOnFilePct: pct(vendorsWithDpa, vendorsTotal),
    systemsCompleteMetaPct: pct(systemsWithCategories, systemsTotal),
    retentionDefinedPct: pct(systemsWithRetention, totalCategories),
    thirdCountryTransferRatio: pct(thirdCountrySystems, systemsTotal),
    estimatedCostPerDsar: costPerDsar,
    estimatedTimeSavedPerDsar: timeSavedPerDsar,
    totalTimeSavedMonthly: totalTimeSavedMonthly,
    maturityScore,
  };

  // Cache for 120 seconds
  await cache.set(ck, result, CacheTTL.EXECUTIVE_KPI);

  return result;
}

/**
 * Store a KPI snapshot for the given date.
 */
export async function storeKpiSnapshot(
  tenantId: string,
  period: KpiSnapshotPeriod = "MONTHLY",
  snapshotDate?: Date,
) {
  const date = snapshotDate || new Date();
  const normalizedDate = new Date(date.getFullYear(), date.getMonth(), 1);

  const kpi = await calculateKPIs(tenantId);

  return prisma.privacyKpiSnapshot.upsert({
    where: {
      tenantId_period_snapshotDate: {
        tenantId,
        period,
        snapshotDate: normalizedDate,
      },
    },
    update: { ...snapshotToData(kpi), rawData: JSON.parse(JSON.stringify(kpi)) },
    create: {
      tenantId,
      period,
      snapshotDate: normalizedDate,
      ...snapshotToData(kpi),
      rawData: JSON.parse(JSON.stringify(kpi)),
    },
  });
}

function snapshotToData(kpi: KpiResult) {
  return {
    totalDsars: kpi.totalDsars,
    openDsars: kpi.openDsars,
    closedDsars: kpi.closedDsars,
    avgTimeToCloseDays: kpi.avgTimeToCloseDays,
    medianTimeToCloseDays: kpi.medianTimeToCloseDays,
    extensionRatePct: kpi.extensionRatePct,
    overdueRatePct: kpi.overdueRatePct,
    dsarsByType: kpi.dsarsByType,
    dsarsLinkedToIncidentPct: kpi.dsarsLinkedToIncidentPct,
    riskDistribution: kpi.riskDistribution,
    highRiskCasesCount: kpi.highRiskCasesCount,
    incidentLinkedHighRiskCount: kpi.incidentLinkedHighRiskCount,
    vendorOverdueCount: kpi.vendorOverdueCount,
    autoSuggestedSystemsPct: kpi.autoSuggestedSystemsPct,
    vendorAutoGeneratedPct: kpi.vendorAutoGeneratedPct,
    templateResponsePct: kpi.templateResponsePct,
    idvAutomationPct: kpi.idvAutomationPct,
    apiReadySystemsPct: kpi.apiReadySystemsPct,
    dpaOnFilePct: kpi.dpaOnFilePct,
    systemsCompleteMetaPct: kpi.systemsCompleteMetaPct,
    retentionDefinedPct: kpi.retentionDefinedPct,
    thirdCountryTransferRatio: kpi.thirdCountryTransferRatio,
    estimatedCostPerDsar: kpi.estimatedCostPerDsar,
    estimatedTimeSavedPerDsar: kpi.estimatedTimeSavedPerDsar,
    totalTimeSavedMonthly: kpi.totalTimeSavedMonthly,
    maturityScore: kpi.maturityScore,
  };
}

/**
 * Get historical KPI snapshots for trend analysis.
 */
export async function getKpiSnapshots(
  tenantId: string,
  months: number = 12,
  period: KpiSnapshotPeriod = "MONTHLY",
) {
  const since = new Date();
  since.setMonth(since.getMonth() - months);

  return prisma.privacyKpiSnapshot.findMany({
    where: {
      tenantId,
      period,
      snapshotDate: { gte: since },
    },
    orderBy: { snapshotDate: "asc" },
  });
}

/**
 * Calculate maturity scores by domain and store them.
 */
export async function calculateMaturityScores(tenantId: string) {
  const kpi = await calculateKPIs(tenantId);
  const now = new Date();
  const month = new Date(now.getFullYear(), now.getMonth(), 1);

  const scores = [
    {
      domain: "DOCUMENTATION" as const,
      score: kpi.systemsCompleteMetaPct ?? 0,
      details: { dpaOnFile: kpi.dpaOnFilePct, retention: kpi.retentionDefinedPct },
    },
    {
      domain: "AUTOMATION" as const,
      score: Math.min(100, (kpi.autoSuggestedSystemsPct ?? 0) * 0.4 + (kpi.templateResponsePct ?? 0) * 0.3 + (kpi.apiReadySystemsPct ?? 0) * 0.3),
      details: { autoSystems: kpi.autoSuggestedSystemsPct, templates: kpi.templateResponsePct, apiReady: kpi.apiReadySystemsPct },
    },
    {
      domain: "SLA_COMPLIANCE" as const,
      score: Math.max(0, 100 - (kpi.overdueRatePct ?? 0)),
      details: { overdueRate: kpi.overdueRatePct, extensionRate: kpi.extensionRatePct },
    },
    {
      domain: "INCIDENT_INTEGRATION" as const,
      score: Math.min(100, (kpi.dsarsLinkedToIncidentPct ?? 0) + 50),
      details: { linkedPct: kpi.dsarsLinkedToIncidentPct, highRisk: kpi.incidentLinkedHighRiskCount },
    },
    {
      domain: "VENDOR_COORDINATION" as const,
      score: kpi.vendorOverdueCount === 0 ? 100 : Math.max(0, 100 - kpi.vendorOverdueCount * 10),
      details: { overdueRequests: kpi.vendorOverdueCount, dpaOnFile: kpi.dpaOnFilePct },
    },
  ];

  for (const s of scores) {
    await prisma.maturityScore.upsert({
      where: {
        tenantId_domain_month: { tenantId, domain: s.domain, month },
      },
      update: { score: s.score, details: s.details },
      create: { tenantId, domain: s.domain, month, score: s.score, details: s.details },
    });
  }

  return scores;
}
